# Стайлгайд для PHP

Базовый гайд — [симфонический](https://symfony.com/doc/current/contributing/code/standards.html).

# Докблоки

В большинстве случаев докблоки не нужны. [Почему?](docs/development/code-style/php/docblocks-motivation.md)

Исключения перечислены далее.

## Класс / Интерфейс / Трейт

Документировать, когда:
- информацию о его предназначении не выразить в имени класса ± неймспейса, или нет на это времени;
- нужно указать примеры использования, а времени писать тесты — нет;
- нужно пометить как `@deprecated`
- нужны аннотации, которые невозможно или нет времени отделить в yaml-конфиг или принято повсеместно использовать:
  - `@Route` в контроллерах
  - `@Entity`, `@Embeddable`, `???` в сущностях
  - `@Constraint`
  - ???

Есть еще «волшебные» `@method` и `@property`, но за их применение предлагается сажать на бутылку.

## Метод

Документировать метод нужно, если:
- хотя бы один из параметров может быть массивом / итератором элементов строго определенного типа (`string[]`, ` Collection|SomeClass[]`)
- возвращаемый тип может быть таким же массивом/итератором
- нужно указать тип выбрасываемого исключения (зачем???)
- нужно пометить как `@deprecated`
- нужны аннотации, которые не отделить в отдельный конфиг или принято повсеместно использовать:
   - `@Route` контроллера
   - `@ParamConverter` в роуте

## Свойства

Единственное, что нужно документировать всегда, ибо иных языковых средств не предусмотрено и не предвидится.

Желательно только соблюдать в классе один из возможных стилей — «горизонтальный» или «вертикальный», не смешивая:
```php
/**
 * @var Foo $foo Vertical example
 **/
private $foo;

/** @var Bar $bar Horizontal example*/
private $bar;
```

## Конструктор

По аналогии с методами — нужно комментировать только, если хотя бы один параметр может быть массивом/итератором значений одного типа.

## `@inheritDoc`

Не нужен (кроме код-ревью???), зато может уронить билд за несоблюдение кодстайла, если написать без фигурных скобок.

## Переменные

Следует максимально избегать, где позволяют возможности IDE / документирования иными способами.

Да, это несколько более хлопотно, зато защищено от устаревания (=> косяков при рефакторинге).

##### Сервисы, извлекаемые `$this->get() ` в контроллере

Можно [инжектить в конструктор](https://symfony.com/doc/3.3/service_container.html#services-constructor-injection) до Symfony 3.3 и [хинтить прямо в метод](https://symfony.com/doc/3.3/controller.html#fetching-services-as-controller-arguments), начиная с 3.3.

Заодно меньше проблем с `private: true` по умолчанию и рефакторинге именованных сервисов.

##### Репозитории, получаемые `$this->getDoctrine()->getRepository($name)`

См. предыдущий пункт.

##### Обход циклом данных из итератора

Типичный случай:

```php
foreach($service->iterateStuff() as $thing) {
    /** @var Foo $thing */
    $thing->fooMethod();
}
```

Это как раз сигнал, что `iterateStuff` 
- либо совсем не задокументирован
- либо покрыт только автогенерацией
- либо дока к нему устарела

Во всех случаях достаточно документировать сам `iterateStuff` хинтом `@return Foo[]`.

Если же это результат работы внешней библиотеки — завернуть в декоратор / адаптер и пр.

