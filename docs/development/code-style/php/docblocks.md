# Докблоки

## Всегда можно писать

- `@deprecated`, `@throws`
- Symfony-аннотации для контроллеров, сущностей и пр.
- `@var` в свойствах класса - только в "вертикальной" форме:

```php
/**
 * @var Foo $foo  Vertical example - OK
 **/
private $foo;

/** @var Bar $bar Horizontal example - NOT OK */
private $bar;
```

## Никогда нельзя писать

В классе - «волшебные» `@method` и `@property`.

?`@inheritDoc`?


# Rule of thumb

> Писать докблоки **обязательно** только тогда, когда они привносят хоть что-либо полезное в код и нет иного способа это сделать.

В остальных случаях докблоки не нужны. [Почему?](docs/development/code-style/php/docblocks-motivation.md)

Если докблок использован, то он должен иметь полную форму - `@param`, `@returns` и пр., по ситуации.

Далее описаны случаи, когда именно докблоки что-либо привносят. 


## Класс / Интерфейс / Трейт

Документировать, когда:
- информацию о его предназначении не выразить в имени класса ± неймспейса, или нет на это времени;
- нужно указать примеры использования класса, а времени писать тесты — нет;

## Метод / Конструктор

Документировать метод нужно, если:
- хотя бы один из `@param` может быть массивом / итератором элементов строго определенного типа (`string[]`, ` Collection|SomeClass[]`)
- `@returns` если возращаемый методом тип может быть таким же массивом/итератором

## Инлайновые `@var`

Следует избегать, где позволяют возможности IDE / документирования иными способами (описаны ниже)

Да, это несколько более хлопотно, зато защищено от устаревания (=> косяков при рефакторинге).

## Решения для замены инлайновых `@var`

#### Сервисы, извлекаемые в контроллере

```php
/** @var $myService MyService */
$myService = $this->get(MyService::class);
$repository = $this->getDoctrine()->getRepository($name);
```

Можно [инжектить в конструктор](https://symfony.com/doc/3.3/service_container.html#services-constructor-injection) до Symfony 3.3 и [хинтить прямо в метод](https://symfony.com/doc/3.3/controller.html#fetching-services-as-controller-arguments), начиная с 3.3.

Заодно меньше проблем с `private: true` по умолчанию и рефакторинге именованных сервисов.

#### Обход циклом данных из итератора

```php
foreach($service->iterateStuff() as $thing) {
    /** @var Foo $thing */
    $thing->fooMethod();
}
```

Это как раз сигнал, что `iterateStuff` 
- либо совсем не задокументирован
- либо покрыт только автогенерацией
- либо дока к нему устарела

Во всех случаях достаточно документировать сам `iterateStuff` хинтом `@return Foo[]`.

Если же это результат работы внешней библиотеки — завернуть в декоратор / адаптер и пр.

